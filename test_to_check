test 109 ---> seg fault
test 113 ---> seg fault
problems with exit status of the echo command



Faire un cas special lors de process_redir si EOF est un expand (needs to go into exec)
Faire un cas dans le heredoc pour que l'expand ne se passe pas quand EOF entre quotes
Faire un cas dans le heredoc pour aue l'EOF ne soit pas expand
Free invalid pointer in expand_utils l.33 but leaks without it so need to check this out
Leaks sur "$HOMEnimportequoi" (test 140), puis more leaks si on enchaine avec $HOMEnimportequoi
Parse exit so that if it contains more that 1 arg it returns "too many arguments" (test 334, 334, 337, 338)
Check cas limite sur exit, ou mettre un message d'erreur (tests 369,371)
Check message errur et exit status sur cd file_not_existing (test 417)
Check input : > name_of_file ---> makes the program runs in a loop
Leaks sur cat Makefile | wc -l
Fix > ok and >> ok which give out an error and don't give prompt back (test 491, 492, 493, 494, 499, 500, 501, 502, 503, 504)
Free invalid pointer (test 520)
Fix	exit status for << $hola, parsed as faulty input (status==2) when it's valid (status==0) (test 542)


Expand dans expand fait tourner le programme en boucle (test 212) PARSING
Seg fault si on essaye d'expand une variable qui n'est pas expandable ou si expandable mais des trucs en plus derriere (tests 141, 139, 218) PARSING
Mauvais code erreur quand on expand une variable sans commande avant (test 140) EXEC
Check les exit_status de unset (test 247) EXEC
Check erreur message quand HOME= et cd apres (test 308, 313, 314) EXEC
Need to fix issue with trying to execute file that doesn't exist, pas le bon exit status (test 322) EXEC
Need to fix error message en limit numeric argument in exit (test 369, 371) EXEC
Need to fix parsing for 3 pipe in a row in a command like so '|||' (test 412) + leaks in exec PARSING+EXEC
Need to figure out output et exit status of test 417 EXEC
Seg fault sur test 442, 466, 467, 478, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505  EXEC
Need to fix loop (test 450, 451, 532, 533, 536) EXEC
Fix expand in EOF du heredoc (test 534) EXEC
Need to fix exit status test 468, 469, 470, 475, 476 EXEC


valgrind --leak-check=full --show-leak-kinds=all --log-file=valgrind_output.%p.txt --suppressions=supp.supp ./minishell

139/142/218 : leaks of actual_expand-->strjoin :

$HOMEdskjhfkdshfsd

$DONTEXIST

export HOLA="l" 
$HOLAs


TODO :
check echo | << EOF (stuck in a loop, doesn't give the prompt back)
check cat | rev (should be blocking command but it gets out after one "enter")
check cat | ls | cat
check heredoc with $? as EOF and all combination with quotes ----> if EOF = "$?" the EOF is expand and it shouldn't so the EOF is transformed in 0
check invaldid pointer when [spaces]+random char


Leaks sur :

$?
$?$?
?$HOME
$HOMEdskjhfkdshfsd
"$HOMEdskjhfkdshfsd"
$DONTEXIST
$LESS$VAR

export HOLA="bonjour      "  
echo $HOLA | cat -e

export HOLA="  bonjour  hey  "  
echo $HOLA | cat -e

export HOLA="  bonjour  hey  "  
echo """$HOLA""" | cat -e

export HOLA="  bonjour  hey  "  
echo wesh"$HOLA" | cat -e

export HOLA="s -la" 
l"$HOLA"

export HOLA="l" 
$HOLAs

export HOLA=p
export BYE=w
$HOLA"BYE"d

export HOLA=p
export BYE=w
$"HOLA"$"BYE"d

export HOLA=-n
"echo $HOLA" hey

export hola | unset hola | echo $?

   cd / | echo $?
pwd



void in_redir_handle(t_line *line, t_env *env)
{
    int fd;
    t_redir *redir;

    redir = line->pipe->redir;
    fd = open(redir->fd, O_RDONLY);
    if (fd == -1)
    {
        print_error_message("minishell: ", redir->fd, ": No such file or directory\n");
        cleanup(line);
        free_env(env);
        exit(1);
    }
    if (dup2(fd, STDIN_FILENO) == -1)
    {
        print_error_message("minishell: ", redir->fd, ": Failed to redirect input\n");
        close(fd);
        cleanup(line);
        free_env(env);
        exit(1);
    }
    close(fd);
}

void out_append_redir_handle(t_line *line, t_env *env)
{
    int fd;
    t_redir *redir;
    int flags;

    redir = line->pipe->redir;
    if (redir->type == APPEND)
        flags = O_WRONLY | O_CREAT | O_APPEND;
    else
        flags = O_WRONLY | O_CREAT | O_TRUNC;
    fd = open(redir->fd, flags, 0644);
    if (fd == -1)
    {
        print_error_message("minishell: ", redir->fd, ": Failed to open output file\n");
        cleanup(line);
        free_env(env);
        exit(1);
    }
    if (dup2(fd, STDOUT_FILENO) == -1)
    {
        print_error_message("minishell: ", redir->fd, ": Failed to redirect output\n");
        close(fd);
        cleanup(line);
        free_env(env);
        exit(1);
    }
    close(fd);
}

int create_process(t_env *env, t_pipe *pipe, int input_fd, int output_fd,
    t_line *line, char *str, int pipe_fd)
{
    pid_t pid = fork();
    if (pid == 0)
    {
        if (pipe_fd > -1)
            close(pipe_fd);
        if (input_fd != STDIN_FILENO)
        {
            if (dup2(input_fd, STDIN_FILENO) == -1)
            {
                perror("dup2 input");
                cleanup(line);
                free_env(env);
                exit(1);
            }
            close(input_fd);
        }
        if (output_fd != STDOUT_FILENO)
        {
            if (dup2(output_fd, STDOUT_FILENO) == -1)
            {
                perror("dup2 output");
                cleanup(line);
                free_env(env);
                exit(1);
            }
            close(output_fd);
        }
        t_redir *redir = pipe->redir;
        while (redir)
        {
            if (redir->type == IN_REDIR)
                in_redir_handle(line, env);
            else if (redir->type == OUT_REDIR || redir->type == APPEND)
                out_append_redir_handle(line, env);
            else if (redir->type == HEREDOC)
            {
                int fd = open(redir->fd, O_RDONLY);
                if (fd != -1)
                {
                    if (dup2(fd, STDIN_FILENO) == -1)
                    {
                        perror("dup2 heredoc");
                        close(fd);
                        cleanup(line);
                        free_env(env);
                        exit(1);
                    }
                    close(fd);
                }
            }
            redir = redir->next;
        }
        if (pipe->arg && pipe->arg[0])
            execute_cmd(env, pipe, line, str);
        free_env(env);
        cleanup_exec(line);
        exit(0);
    }
    return pid;
}
